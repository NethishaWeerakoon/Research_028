PDF2TXT(page_content=[{'page_number': 0, 'content': ''}, {'page_number': 1, 'content': '  C++ \ni \n \nAbout the T utorial  \nC++ is a middle -level programming language developed by Bjarne Stroustrup in 1979 at \nBell Labs. C++ runs on a variety of platforms, such as Windows, Mac OS, and the various \nversions of UNIX.  \nThis tutorial adopts a simple and practical approach to describe the concepts of C++.  \nAudience  \nThis tutorial has been prepared for the beginners to help them understand the basic to \nadvanced concepts related to C++.  \nPrerequisites  \nBefore you begin practicing various examples given in this tutorial, w e are making an \nassumption that you are already aware of some basics, like the computer software \ninstallation process and computer programming language.  \nCopyright & Disclaimer  \n\uf0e3 Copyright 2014 by Tutorials Point (I) Pvt. Ltd.  \nAll the content and graphics published in this e -book are the property of Tutorials Point (I) \nPvt. Ltd.  The user of this e -book is prohibited to reuse, retain, copy, distribute or republish \nany contents or a part of contents of this e -book in any manner without written consent \nof the  publisher.   \nWe strive to update the contents of our website and tutorials as timely and as precisely as \npossible, however, the contents may contain inaccuracies or errors. Tutorials Point (I) Pvt. \nLtd. provides no guarantee regarding the accuracy, timeli ness or completeness of our \nwebsite or its contents including this tutorial. If you discover any errors on our website or \nin this tutorial, please notify us at contact@tutorialspoint.com  \n \n \n \n \n \n \n \n \n \n \n \n '}, {'page_number': 2, 'content': '  C++ \nii \n \n \n \nT able  of Contents  \nAbout the Tutorial  ................................ ................................ ................................ ................................ ............  i  \nAudience ................................ ................................ ................................ ................................ ...........................  i \nPrerequisites  ................................ ................................ ................................ ................................ .....................  i \nCopyright & Disclaimer  ................................ ................................ ................................ ................................ ..... i \n1. OVERVIEW  ................................ ................................ ................................ ..............................  1 \nObject -Oriented Programming  ................................ ................................ ................................ ........................  1 \nStandard Libraries  ................................ ................................ ................................ ................................ ............  1 \nThe ANSI Standard  ................................ ................................ ................................ ................................ ...........  1 \nLearning C++  ................................ ................................ ................................ ................................ ....................  2 \n2. ENVIRONMENT SETUP  ................................ ................................ ................................ ............  3 \nTry it Option Online  ................................ ................................ ................................ ................................ .........  3 \n3. BASIC SYNTAX  ................................ ................................ ................................ .........................  5 \nC++ Program Structure  ................................ ................................ ................................ ................................ ..... 5 \nCompile & Execute C++ Program  ................................ ................................ ................................ ......................  6 \nSemicolons & Blocks in C++  ................................ ................................ ................................ ..............................  6 \nC++ Keywords  ................................ ................................ ................................ ................................ ..................  7 \n4. COMMENTS IN C++  ................................ ................................ ................................ ...............  10 \n5. DATA TYPES  ................................ ................................ ................................ ...........................  11 \nPrimitive Built -in Types  ................................ ................................ ................................ ................................ .. 11 \ntypedef Declarations  ................................ ................................ ................................ ................................ ..... 13 \nEnumerated Types  ................................ ................................ ................................ ................................ .........  14 \n6. VARIABLE TYPES  ................................ ................................ ................................ ....................  15 '}, {'page_number': 3, 'content': '  C++ \niii \n \nVariable Definition in C++  ................................ ................................ ................................ ..............................  15 \nVariable Declaration in C++  ................................ ................................ ................................ ............................  16 \nLvalues and Rvalues  ................................ ................................ ................................ ................................ .......  18 \n7. VARIABLE SCOPE  ................................ ................................ ................................ ...................  19 \nLocal Variables  ................................ ................................ ................................ ................................ ...............  19 \nGlobal Variables ................................ ................................ ................................ ................................ .............  20 \nInitializing Local and Global Variabl es ................................ ................................ ................................ ............  21 \n8. CONSTANTS/LITERAL S ................................ ................................ ................................ ...........  22 \nInteger Literals  ................................ ................................ ................................ ................................ ...............  22 \nFloating -point Literals  ................................ ................................ ................................ ................................ .... 22 \nBoolean Literals  ................................ ................................ ................................ ................................ .............  23 \nCharacter Literals  ................................ ................................ ................................ ................................ ...........  23 \nString Literals  ................................ ................................ ................................ ................................ .................  24 \nDefining Constants  ................................ ................................ ................................ ................................ .........  25 \n9. MODIFIER TYPES  ................................ ................................ ................................ ...................  27 \nType Qualifiers in C++  ................................ ................................ ................................ ................................ .... 28 \n10. STORAGE CLASSES  ................................ ................................ ................................ ...............  29 \nThe auto Storage Class  ................................ ................................ ................................ ................................ ... 29 \nThe register Storage Class  ................................ ................................ ................................ ..............................  29 \nThe static Storage Class  ................................ ................................ ................................ ................................ . 29 \nThe extern Storage Class  ................................ ................................ ................................ ................................  31 \nThe mutable Storage Class  ................................ ................................ ................................ .............................  32 \n11. OPERATORS  ................................ ................................ ................................ .........................  33 \nArithmetic Operators  ................................ ................................ ................................ ................................ ..... 33 \nRelational Operators ................................ ................................ ................................ ................................ ...... 35 \nLogical Operators  ................................ ................................ ................................ ................................ ...........  37 '}, {'page_number': 4, 'content': '  C++ \niv \n \nBitwise Operators  ................................ ................................ ................................ ................................ ..........  39 \nAssignment Operators  ................................ ................................ ................................ ................................ ... 41 \nMisc Operators  ................................ ................................ ................................ ................................ ..............  44 \nOperators Precedence in C++  ................................ ................................ ................................ .........................  45 \n12. LOOP TYPES  ................................ ................................ ................................ .........................  48 \nWhile Loop  ................................ ................................ ................................ ................................ ....................  49 \nLoop Control Statements  ................................ ................................ ................................ ...............................  57 \nThe Infinite Loop  ................................ ................................ ................................ ................................ ............  63 \n13. DECISION -MAKING STATEMENTS  ................................ ................................ ........................  65 \nIf Statement  ................................ ................................ ................................ ................................ ...................  66 \nif…else Statement  ................................ ................................ ................................ ................................ ..........  67 \nif...else if...else Statement  ................................ ................................ ................................ .............................  69 \nSwitch Statement  ................................ ................................ ................................ ................................ ..........  71 \nNested if Statement  ................................ ................................ ................................ ................................ .......  73 \nThe ? : Operator  ................................ ................................ ................................ ................................ .............  76 \n14. FUNCTIONS  ................................ ................................ ................................ .........................  77 \nDefining a Function  ................................ ................................ ................................ ................................ ........  77 \nFunction Declarations  ................................ ................................ ................................ ................................ .... 78 \nCalling a Function  ................................ ................................ ................................ ................................ ..........  78 \nFunction Arguments  ................................ ................................ ................................ ................................ ...... 80 \n15. NUMBERS  ................................ ................................ ................................ ...........................  87 \nDefining Numbers in C++  ................................ ................................ ................................ ...............................  87 \nMath Operations in C++  ................................ ................................ ................................ ................................ . 88 \nRandom Numbers in C++  ................................ ................................ ................................ ...............................  90 \n16. ARRAYS  ................................ ................................ ................................ ...............................  92 \nDeclaring Arrays  ................................ ................................ ................................ ................................ ............  92 '}, {'page_number': 5, 'content': '  C++ \nv \n \nInitializing Arrays  ................................ ................................ ................................ ................................ ...........  92 \nAccessing Array Elements  ................................ ................................ ................................ ..............................  93 \nArrays in C++  ................................ ................................ ................................ ................................ ..................  94 \nPassing Arrays to Functions  ................................ ................................ ................................ ...........................  98 \n17. STRINGS  ................................ ................................ ................................ ............................  104 \nThe C -Style Character String  ................................ ................................ ................................ ........................  104 \nThe String Class in C++  ................................ ................................ ................................ ................................ . 106 \n18. POINTERS  ................................ ................................ ................................ ..........................  108 \nWhat are Pointers?  ................................ ................................ ................................ ................................ ...... 108 \nUsing Pointers in C++  ................................ ................................ ................................ ................................ ... 109 \nPointers in C++  ................................ ................................ ................................ ................................ .............  110 \nNull Pointers  ................................ ................................ ................................ ................................ ................  111 \nPointer Arithmetic  ................................ ................................ ................................ ................................ .......  111 \nPointers vs Arrays  ................................ ................................ ................................ ................................ ........  115 \nArray of Pointers  ................................ ................................ ................................ ................................ ..........  117 \nPointer to a Pointer  ................................ ................................ ................................ ................................ ..... 119 \nPassing Pointers to Functions  ................................ ................................ ................................ ......................  120 \nReturn Pointer from Functions  ................................ ................................ ................................ ....................  123 \n19. REFERENCES  ................................ ................................ ................................ ......................  126 \nReferences vs Pointers  ................................ ................................ ................................ ................................ . 126 \nCreating References in C++  ................................ ................................ ................................ ..........................  126 \nReferences as Parameters  ................................ ................................ ................................ ............................  127 \nReference as Return Value  ................................ ................................ ................................ ...........................  129 \n20. DATE AND TIME  ................................ ................................ ................................ ................  131 \nCurrent Date and Time  ................................ ................................ ................................ ................................  132 \nFormat Time using struct tm  ................................ ................................ ................................ ........................  133 '}, {'page_number': 6, 'content': '  C++ \nvi \n \n21. BASIC INPUT/OUTP UT ................................ ................................ ................................ .......  135 \nI/O Library Header Files  ................................ ................................ ................................ ...............................  135 \nThe Standard Output Stream (c out)  ................................ ................................ ................................ .............  135 \nThe Standard Input Stream (cin)  ................................ ................................ ................................ ..................  136 \nThe Standard Error Stream (cerr)  ................................ ................................ ................................ .................  137 \nThe Standard Log Stream (clog)  ................................ ................................ ................................ ...................  137 \n22. DATA STRUCTURES  ................................ ................................ ................................ ............  139 \nDefining a Structure  ................................ ................................ ................................ ................................ ..... 139 \nAccessing Structure Members  ................................ ................................ ................................ ......................  140 \nStructures as Function Arguments  ................................ ................................ ................................ ...............  141 \nPointers to Structures  ................................ ................................ ................................ ................................ .. 143 \n23. CLASSES AND OBJECTS  ................................ ................................ ................................ ...... 146 \nC++ Class Definitions  ................................ ................................ ................................ ................................ .... 146 \nDefine C++ Objects ................................ ................................ ................................ ................................ .......  146 \nClasses & Objects in Detail  ................................ ................................ ................................ ...........................  148 \nClass Access Modifiers  ................................ ................................ ................................ ................................ . 152 \nThe public Members  ................................ ................................ ................................ ................................ .... 153 \nThe private Members  ................................ ................................ ................................ ................................ .. 154 \nThe protected Members  ................................ ................................ ................................ ..............................  156 \nConstructor & Destructor ................................ ................................ ................................ .............................  157 \nFriend Functions  ................................ ................................ ................................ ................................ ..........  167 \nInline Functions  ................................ ................................ ................................ ................................ ...........  168 \nthis Pointer  ................................ ................................ ................................ ................................ ..................  169 \nPointer to C++ Classes  ................................ ................................ ................................ ................................ .. 171 \nStatic Members of a Class  ................................ ................................ ................................ ............................  173 \nStatic Function Members  ................................ ................................ ................................ .............................  174 \n24. INHERITANCE  ................................ ................................ ................................ ....................  177 '}, {'page_number': 7, 'content': '  C++ \nvii \n \nBase & Derived Classes  ................................ ................................ ................................ ................................  177 \nAccess Control and Inheritance  ................................ ................................ ................................ ....................  179 \nType of Inheritance  ................................ ................................ ................................ ................................ ...... 179 \nMultiple Inheritance  ................................ ................................ ................................ ................................ .... 180 \n25. OVERLOADING (OPE RATOR & FUNCTION)  ................................ ................................ ........  182 \nFunction Overlo ading in C++  ................................ ................................ ................................ ........................  182 \nOverloadable/Non -overloadable Operators  ................................ ................................ ................................  186 \nOperator Overloading Examples  ................................ ................................ ................................ ..................  186 \nUnary Operators Overloading  ................................ ................................ ................................ ......................  187 \nIncrement (++) and Decrem ent ( - -) Operators  ................................ ................................ .............................  189 \nBinary Operators Overloading  ................................ ................................ ................................ .....................  191 \nRelational Operators Overloading  ................................ ................................ ................................ ...............  193 \nInput/Output Operators Overloading  ................................ ................................ ................................ ..........  195 \n++ and - - Operators Overloading  ................................ ................................ ................................ .................  197 \nAssignment Operators Overloading  ................................ ................................ ................................ .............  199 \nFunction Call () Operator Overloading  ................................ ................................ ................................ .........  201 \nSubscripting [ ] Operator Overloading  ................................ ................................ ................................ .........  202 \nClass Member Access Operator - > Overloading  ................................ ................................ ...........................  204 \n26. POLYM ORPHISM  ................................ ................................ ................................ ...............  208 \nVirtual Function  ................................ ................................ ................................ ................................ ...........  210 \n27. DATA ABSTRACTION  ................................ ................................ ................................ ..........  212 \nAccess Labels Enforce Abstraction  ................................ ................................ ................................ ...............  213 \n28. DATA ENCAPSULAT ION ................................ ................................ ................................ ..... 215 \n29. INTERFACES ................................ ................................ ................................ .......................  218 \n30. FILES AND STREAM S ................................ ................................ ................................ ..........  221 \nOpening a File  ................................ ................................ ................................ ................................ ..............  221 '}, {'page_number': 8, 'content': '  C++ \nviii \n \nClosing a File  ................................ ................................ ................................ ................................ ................  222 \nWriting to a File  ................................ ................................ ................................ ................................ ...........  222 \nFile Position Pointers  ................................ ................................ ................................ ................................ ... 224 \n31. EXCEPTION HANDLI NG ................................ ................................ ................................ ...... 226 \nThrowing Exceptions  ................................ ................................ ................................ ................................ .... 226 \nCatching Exceptions  ................................ ................................ ................................ ................................ ..... 227 \nC++ Standard Exceptions ................................ ................................ ................................ ..............................  228 \nDefine New Exceptions  ................................ ................................ ................................ ................................  230 \n32. DYNAMIC MEMORY  ................................ ................................ ................................ ..........  232 \nThe new and delete Operators  ................................ ................................ ................................ ....................  232 \nDynamic Memory Allocation for Arrays  ................................ ................................ ................................ .......  233 \nDynamic Memory Allocation for Objects  ................................ ................................ ................................ ..... 234 \n33. NAMESPACES  ................................ ................................ ................................ ....................  236 \nDefining a Namespace  ................................ ................................ ................................ ................................ . 236 \nThe using directive  ................................ ................................ ................................ ................................ .......  237 \nDiscontiguous Namespaces  ................................ ................................ ................................ .........................  239 \nNested Namespaces  ................................ ................................ ................................ ................................ .... 239 \n34. TEMPLATES  ................................ ................................ ................................ .......................  241 \nFunction Template  ................................ ................................ ................................ ................................ .......  241 \nClass Template  ................................ ................................ ................................ ................................ .............  242 \n35. PREPROCESSOR  ................................ ................................ ................................ .................  245 \nThe #define Preprocessor  ................................ ................................ ................................ ............................  245 \nFunction -Like Macros  ................................ ................................ ................................ ................................ ... 246 \nConditional Compilation  ................................ ................................ ................................ ..............................  246 \nThe # and # # Operators  ................................ ................................ ................................ ...............................  248 \nPredefined C++ Macros  ................................ ................................ ................................ ................................  249 '}, {'page_number': 9, 'content': '  C++ \nix \n \n36. SIGNAL HANDLING  ................................ ................................ ................................ ............  251 \nThe signal() Function  ................................ ................................ ................................ ................................ .... 251 \nThe raise() Function  ................................ ................................ ................................ ................................ ..... 253 \n37. MULTITHREADING ................................ ................................ ................................ .............  255 \nCreating Threads  ................................ ................................ ................................ ................................ ..........  255 \nTerminating Threads  ................................ ................................ ................................ ................................ .... 256 \nPassing Arguments to Threads  ................................ ................................ ................................ .....................  257 \nJoining and Detaching Thr eads  ................................ ................................ ................................ ....................  259 \n38. WEB PROGRAMMING  ................................ ................................ ................................ .......  263 \nWhat is CGI?  ................................ ................................ ................................ ................................ ................  263 \nWeb Browsing  ................................ ................................ ................................ ................................ .............  263 \nCGI Architecture Diagram  ................................ ................................ ................................ ............................  264 \nWeb Server Configuration ................................ ................................ ................................ ............................  264 \nHTTP Header  ................................ ................................ ................................ ................................ ................  266 \nCGI Environment Variables  ................................ ................................ ................................ ..........................  266 \nC++ CGI Library  ................................ ................................ ................................ ................................ ............  269 \nGET and POST Methods  ................................ ................................ ................................ ...............................  270 \nUsing Cookies in CGI  ................................ ................................ ................................ ................................ .... 279 \n39. STL TUTORIAL  ................................ ................................ ................................ ....................  286 \n40. STANDARD LIBRARY  ................................ ................................ ................................ ..........  289 \nThe Standard Function Library  ................................ ................................ ................................ .....................  289 \nThe Object Oriented Class Library  ................................ ................................ ................................ ................  289 \n \n '}, {'page_number': 10, 'content': '  C++ \n10 \n \nC++ is a statically typed, compiled, general -purpose, case -sensitive, free -form programming \nlanguage that supports procedural, object -oriented, and generic programming.  \nC++ is regarded as a  middle -level  language, as it comprises a combination of both high -\nlevel and low -level language features.  \nC++ was developed by Bjarne Stroustrup starting in 1979 at Bell Labs in Murray Hill, New \nJersey, as an enhancement to the C language and originally named C wi th Classes but later \nit was renamed C++ in 1983.  \nC++ is a superset of C, and that virtually any legal C program is a legal C++ program.  \nNote:  A programming language is said to use static typing when type checking is performed \nduring compile -time as opposed  to run -time. \nObject -Oriented Programming  \nC++ fully supports object -oriented programming, including the four pillars of object -oriented \ndevelopment:  \n\uf0b7 Encapsulation  \n\uf0b7 Data hiding  \n\uf0b7 Inheritance  \n\uf0b7 Polymorphism  \nStandard Libraries  \nStandard C++ consists of three import ant parts:  \n\uf0b7 The core language giving all the building blocks including variables, data types and \nliterals, etc.  \n\uf0b7 The C++ Standard Library giving a rich set of functions manipulating files, strings, etc.  \n\uf0b7 The Standard Template Library (STL) giving a rich set o f methods manipulating data \nstructures, etc.  1. OVERVIEW  '}, {'page_number': 11, 'content': "  C++ \n11 \n \nThe ANSI Standard  \nThe ANSI standard is an attempt to ensure that C++ is portable; that code you write for \nMicrosoft's compiler will compile without errors, using a compiler on a Mac, UNIX, a Windows \nbox, or an A lpha. \nThe ANSI standard has been stable for a while, and all the major C++ compiler manufacturers \nsupport the ANSI standard.  \nLearning C++  \nThe most important thing while learning C++ is to focus on concepts.  \nThe purpose of learning a programming language i s to become a better programmer; that is, \nto become more effective at designing and implementing new systems and at maintaining old \nones.  \nC++ supports a variety of programming styles. You can write in the style of Fortran, C, \nSmalltalk, etc., in any langua ge. Each style can achieve its aims effectively while maintaining \nruntime and space efficiency.  \nUse of C++  \nC++ is used by hundreds of thousands of programmers in essentially every application \ndomain.  \nC++ is being highly used to write device drivers and oth er software that rely on direct \nmanipulation of hardware under real -time constraints.  \nC++ is widely used for teaching and research because it is clean enough for successful \nteaching of basic concepts.  \nAnyone who has used either an Apple Macintosh or a PC r unning Windows has indirectly used \nC++ because the primary user interfaces of these systems are written in C++.  "}, {'page_number': 12, 'content': '  C++ \n12 \n \nTry it Option Online  \nYou really do not need to set up your own environment to start learning C++ programming \nlanguage. Reas on is very simple, we have already set up C++ Programming environment \nonline, so that you can compile and execute all the available examples online at the same \ntime when you are doing your theory work. This gives you confidence in what you are reading \nand to check the result with different options. Feel free to modify any example and execute \nit online.  \nTry the following example using our online compiler  option available at \nhttp://www.compileonline.com/  \n#include  <iostream>  \nusing namespace  std; \n \nint main() \n{ \n   cout << "Hello World" ; \n   return 0; \n} \nFor most of the examples given in this tutorial, you will find  Try it  option in our website code \nsections at the top right corner that will take you to the online compil er. So just make use of \nit and enjoy your learning.  \nLocal Environment Setup  \nIf you are still willing to set up your environment for C++, you need to have the following two \nsoftwares on your computer.  \nText Editor  \nThis will be used to type your program. Exam ples of few editors include Windows Notepad, \nOS Edit command, Brief, Epsilon, EMACS, and vim or vi.  \nName and version of text editor can vary on different operating systems. For example, \nNotepad will be used on Windows and vim or vi can be used on windows a s well as Linux, or \nUNIX.  2. ENVIRO NMENT SETUP  '}, {'page_number': 13, 'content': "  C++ \n13 \n \nThe files you create with your editor are called source files and for C++ they typically are \nnamed with the extension .cpp, .cp, or .c.  \nA text editor should be in place to start your C++ programming.  \nC++ Compiler  \nThis is an actual  C++ compiler, which will be used to compile your source code into final \nexecutable program.  \nMost C++ compilers don't care what extension you give to your source code, but if you don't \nspecify otherwise, many will use .cpp by default.  \nMost frequently used and free available compiler is GNU C/C++ compiler, otherwise you can \nhave compilers either from HP or Solaris if you have the respective Operating Systems.  \nInstalling GNU C/C++ Compiler:  \nUNIX/Linux Installation  \nIf you are using  Linux or UNIX  then check whe ther GCC is installed on your system by \nentering the following command from the command line:  \n$ g++ -v \nIf you have installed GCC, then it should print a message such as the following:  \nUsing built-in specs. \nTarget: i386-redhat-linux \nConfigured  with: ../configure --prefix=/usr ....... \nThread model: posix \ngcc version 4.1.2 20080704  (Red Hat 4.1.2-46) \nIf GCC is not installed, then you will have to install it yourself using the detailed instructions \navailable at  http://gcc.gnu.org/install/  . \nMac OS X Installatio n \nIf you use Mac OS X, the easiest way to obtain GCC is to download the Xcode development \nenvironment from Apple's website and follow the simple installation instructions.  \nXcode is currently available at  developer.apple.com/technologies/tools/.  \nWindows Ins tallation  \nTo install GCC at Windows you need to install MinGW. To install MinGW, go to the MinGW \nhomepage,  www.mingw.org,  and follow the link to the MinGW download page. Download the "}, {'page_number': 14, 'content': '  C++ \n14 \n \nlatest version of the MinGW installation program which should be named Mi nGW-\n<version>.exe.  \nWhile installing MinGW, at a minimum, you must install gcc -core, gcc -g++, binutils, and the \nMinGW runtime, but you may wish to install more.  \nAdd the bin subdirectory of your MinGW installation to your  PATH  environment variable so \nthat yo u can specify these tools on the command line by their simple names.  \nWhen the installation is complete, you will be able to run gcc, g++, ar, ranlib, dlltool, and \nseveral other GNU tools from the Windows command line.  '}, {'page_number': 15, 'content': '  C++ \n15 \n \nWhen we consider a C++  program, it can be defined as a collection of objects that \ncommunicate via invoking each other\'s methods. Let us now briefly look into what a class, \nobject, methods, and instant variables mean.  \n\uf0b7 Object - Objects have states and behaviors. Example: A dog ha s states - color, name, \nbreed as well as behaviors - wagging, barking, and eating. An object is an instance of \na class.  \n\uf0b7 Class - A class can be defined as a template/blueprint that describes the \nbehaviors/states that object of its type support.  \n\uf0b7 Methods - A method is basically a behavior. A class can contain many methods. It is \nin methods where the logics are written, data is manipulated and all the actions are \nexecuted.  \n\uf0b7 Instant Variables - Each object has its unique set of instant variables. An object\'s \nstate is created by the values assigned to these instant variables.  \nC++ Program Structure  \nLet us look at a simple code that would print the words  Hello World . \n#include  <iostream>  \nusing namespace  std; \n \n// main() is where program execution begins.  \n \nint main() \n{ \n   cout << "Hello World" ; // prints Hello World  \n   return 0; \n} \nLet us look at the various parts of the above program:  \n1. The C++ language defines several headers, which contain information that is either \nnecessary or useful to your program. For this program, the header  <iostream>  is \nneeded.  3. BASIC SYNTAX  '}, {'page_number': 16, 'content': '  C++ \n16 \n \n2. The line  using namespace std;  tells the compiler to use the std namespace. \nNamespaces are a relatively recent addition to C++.  \n3. The next line  ‘// main() is where program execution begins.’  is a single -line \ncomment available in C++. Single -line comments begin with // and stop at the end of \nthe line.  \n4. The line  int main()  is the main function where program execution begins.  \n5. The next line  cout << "This is my first C++ program.";  causes the message "This \nis my first C++ program" to  be displayed on the screen.  \n6. The next line  return 0;  terminates main() function and causes it to return the value 0 \nto the calling process.  \nCompile & Execute C++ Program  \nLet\'s look at how to save the file, compile and run the program. Please follow the ste ps given \nbelow:  \n1. Open a text editor and add the code as above.  \n2. Save the file as: hello.cpp  \n3. Open a command prompt and go to the directory where you saved the file.  \n4. Type \'g++ hello.cpp\' and press enter to compile your code. If there are no errors in \nyour code  the command prompt will take you to the next line and would generate a.out \nexecutable file.  \n5. Now, type \'a.out\' to run your program.  \n6. You will be able to see \' Hello World \' printed on the window.  \n$ g++ hello.cpp \n$ ./a.out \nHello World \nMake sure that g++ is i n your path and that you are running it in the directory containing file \nhello.cpp.  \nYou can compile C/C++ programs using makefile. For more details, you can check \nour ‘Makefile Tutorial ’. \nSemicolons & Blocks in C++  \nIn C++, the semicolon is a statement term inator. That is, each individual statement must be \nended with a semicolon. It indicates the end of one logical entity.  \nFor example, following are three different statements:  '}, {'page_number': 17, 'content': '  C++ \n17 \n \nx = y; \ny = y+1; \nadd(x, y); \nA block is a set of logically connected statements that  are surrounded by opening and closing \nbraces. For example:  \n{ \n   cout << "Hello World" ; // prints Hello World  \n   return 0; \n} \nC++ does not recognize the end of the line as a terminator. For this reason, it does not matter \nwhere you put a statement in a line . For example:  \nx = y; \ny = y+1; \nadd(x, y); \nis the same as  \nx = y; y = y+1; add(x, y); \nC++ Identifiers  \nA C++ identifier is a name used to identify a variable, function, class, module, or any other \nuser-defined item. An identifier starts with a letter A to Z o r a to z or an underscore (_) \nfollowed by zero or more letters, underscores, and digits (0 to 9).  \nC++ does not allow punctuation characters such as @, $, and % within identifiers. C++ is a \ncase-sensitive programming language. Thus,  Manpower  and manpower  are two different \nidentifiers in C++.  \nHere are some examples of acceptable identifiers:  \nmohd       zara    abc   move_name  a_123  \nmyname50   _temp   j     a23b9      retVal  \nC++ Keywords  \nThe following list shows the reserved words in C++. These reserved words  may not be used \nas constant or variable or any other identifier names.  '}, {'page_number': 18, 'content': '  C++ \n18 \n \nasm else new this \nauto enum  operator  throw  \nbool explicit  private  true \nbreak  export  protected  try \ncase extern  public  typedef  \ncatch  false register  typeid  \nchar float reinterpret_cas t typename  \nclass for return  union  \nconst  friend  short unsigned  \nconst_cast  goto signed  using  \ncontinue  if sizeof  virtual  \ndefault  inline  static  void \ndelete  int static_cast  volatile  \ndo long struct  wchar_t  \ndouble  mutable  switch  while \ndynamic_cast  namesp ace template    '}, {'page_number': 19, 'content': "  C++ \n19 \n \nTrigraphs  \nA few characters have an alternative representation, called a trigraph sequence. A trigraph is \na three -character sequence that represents a single character and the sequence always starts \nwith two question marks.  \nTrigraphs are exp anded anywhere they appear, including within string literals and character \nliterals, in comments, and in preprocessor directives.  \nFollowing are most frequently used trigraph sequences:  \nTrigraph  Replacement  \n??= # \n??/ \\ \n??' ^ \n??( [ \n??) ] \n??! | \n??< { \n??> } \n??- ~ \n \nAll the compilers do not support trigraphs and they are not advised to be used because of \ntheir confusing nature.  \nWhitespace in C++  \nA line containing only whitespace, possibly with a comment, is known as a blank line, and \nC++ compiler totall y ignores it.  \nWhitespace is the term used in C++ to describe blanks, tabs, newline characters and \ncomments. Whitespace separates one part of a statement from another and enables the "}, {'page_number': 20, 'content': '  C++ \n20 \n \ncompiler to identify where one element in a statement, such as int, ends a nd the next element \nbegins. Statement 1:  \nint age; \nIn the above statement there must be at least one whitespace character (usually a space) \nbetween int and age for the compiler to be able to distinguish them. Statement 2:  \nfruit = apples + oranges;   // Get the total fruit  \nIn the above statement 2, no whitespace characters are necessary between fruit and =, or \nbetween = and apples, although you are free to include some if you wish for readability \npurpose.  '}, {'page_number': 21, 'content': '  C++ \n21 \n \nProgram comments are explanatory st atements that you can include in the C++ code . These \ncomments help  anyone reading the source code. All programming languages allow for some \nform of comments.  \nC++ supports single -line and multi -line comments. All characters available inside any \ncomment are ignored by C++ compiler.  \nC++ comments start with /* and end with */. For example:  \n/* This is a comment */  \n \n/* C++ comments can also  \n * span multiple lines  \n */ \nA comment can also start with //, extending to the end of the line. For example:  \n#include <iostre am> \nusing namespace std;  \n \nmain() \n{ \n   cout << "Hello World"; // prints Hello World  \n \n   return 0;  \n} \nWhen the above code is compiled, it will ignore  // prints Hello World  and final executable \nwill produce the following result:  \nHello World \nWithin a /* and */ comment, // characters have no special meaning. Within a // comment, /* \nand */ have no special meaning. Thus, you can "nest" one kind of comment within the other \nkind. For example:  4. COMMENTS IN C++  '}, {'page_number': 22, 'content': '  C++ \n22 \n \n/* Comment out printing of Hello World:  \n \ncout << "Hello World"; // prints H ello World  \n*/ '}, {'page_number': 23, 'content': '  C++ \n23 \n \nWhile writing program in any language, you need to use various variables to store various \ninformation. Variables are nothing but reserved memory locations to store values. This means \nthat when you create a variable you reserve s ome space in memory.  \nYou may like to store information of various data types like character, wide character, integer, \nfloating point, double floating point, boolean etc. Based on the data type of a variable, the \noperating system allocates memory and decide s what can be stored in the reserved memory.  \nPrimitive Built -in T ypes  \nC++ offers the programmer a rich assortment of built -in as well as user defined data types. \nFollowing table lists down seven basic C++ data types:  \nType  Keyword  \nBoolean  bool \nCharacter  char \nInteger  int \nFloating point  float \nDouble floating point  double  \nValueless  void \nWide character  wchar_t  \n \nSeveral of the basic types can be modified using one or more of these type modifiers:  \n\uf0b7 signed  \n\uf0b7 unsigned  \n\uf0b7 short 5. DATA TYPES  '}, {'page_number': 24, 'content': '  C++ \n24 \n \n\uf0b7 long \nThe following table shows the va riable type, how much memory it takes to store the value in \nmemory, and what is maximum and minimum value which can be stored in such type of \nvariables.  \nType  Typical Bit Width  Typical Range  \nchar 1byte  -127 to 127 or 0 to 255  \nunsigned char  1byte  0 to 255  \nsigned char  1byte  -127 to 127  \nint 4bytes  -2147483648 to 2147483647  \nunsigned int  4bytes  0 to 4294967295  \nsigned int  4bytes  -2147483648 to 2147483647  \nshort int  2bytes  -32768 to 32767  \nunsigned short int  Range  0 to 65,535  \nsigned short int  Range  -32768 to  32767  \nlong int  4bytes  -2,147,483,647 to 2,147,483,647  \nsigned long int  4bytes  same as long int  \nunsigned long int  4bytes  0 to 4,294,967,295  \nfloat 4bytes  +/- 3.4e +/ - 38 (~7 digits)  \ndouble  8bytes  +/- 1.7e +/ - 308 (~15 digits)  \nlong double  8bytes  +/- 1.7e +/- 308 (~15 digits)  '}, {'page_number': 25, 'content': '  C++ \n25 \n \nwchar_t  2 or 4 bytes  1 wide character  \nThe size of variables might be different from those shown in the above table, depending on \nthe compiler and the computer you are using.  \nFollowing is the example, which will produce correct size  of various data types on your \ncomputer.  \n#include  <iostream>  \nusing namespace  std; \n \nint main() \n{ \n   cout << "Size of char : "  << sizeof(char) << endl; \n   cout << "Size of int : "  << sizeof(int) << endl; \n   cout << "Size of short int : "  << sizeof(short int) << endl; \n   cout << "Size of long int : "  << sizeof(long int) << endl; \n   cout << "Size of float : "  << sizeof(float) << endl; \n   cout << "Size of double : "  << sizeof(double) << endl; \n   cout << "Size of wchar_t : "  << sizeof(wchar_t) << endl; \n   return 0; \n} \nThis example uses  endl, which inserts a new -line character after every line and << operator \nis being used to pass multiple values out to the screen. We are also using  sizeof()  function \nto get size of various data types.  \nWhen the above code is compiled  and executed, it produces the following result which can \nvary from machine to machine:  \nSize of char : 1 \nSize of int : 4 \nSize of short int : 2 \nSize of long int : 4 \nSize of float : 4 \nSize of double : 8 \nSize of wchar_t : 4 '}, {'page_number': 26, 'content': '  C++ \n26 \n \ntypedef Declarations  \nYou can create  a new name for an existing type using  typedef . Following is the simple syntax \nto define a new type using typedef:  \ntypedef type newname ;  \nFor example, the following tells the compiler that feet is another name for int:  \ntypedef int feet; \nNow, the following declaration is perfectly legal and creates an integer variable called \ndistance:  \nfeet distance ; \nEnumerated T ypes  \nAn enumerated type declares an optional type name and a set of zero or more identifiers that \ncan be used as values of the type. Each enumerator is a constant whose type is the \nenumeration.  \nCreating an enumeration requires the use of the keyword  enum . The general form of an \nenumeration type is:  \nenum enum-name { list of names } var-list;  \nHere, the enum -name is the enumeration\'s type name. The list of names is comma separated.  \nFor example, the following code defines an enumeration of colors called colors and the variable \nc of type color. Finally, c is assigned the value "blue".  \nenum color { red, green, blue } c; \nc = blue; \nBy default, the value of the  first name is 0, the second name has the value 1, and the third \nhas the value 2, and so on. But you can give a name, a specific value by adding an initializer. \nFor example, in the following enumeration,  green  will have the value 5.  \nenum color { red, green=5, blue }; \nHere,  blue  will have a value of 6 because each name will be one greater than the one that \nprecedes it.  '}, {'page_number': 27, 'content': "  C++ \n27 \n \nA variable provides us with named storage that our programs can manipulate. Each variable \nin C++ has a specific type, which  determines the size and layout of the variable's memory; \nthe range of values that can be stored within that memory; and the set of operations that can \nbe applied to the variable.  \nThe name of a variable can be composed of letters, digits, and the underscor e character. It \nmust begin with either a letter or an underscore. Upper and lowercase letters are distinct \nbecause C++ is case -sensitive:  \nThere are following basic types of variable in C++ as explained in last chapter:  \nType  Description  \nbool Stores either value true or false.  \nchar Typically a single octet (one byte). This is an integer type.  \nint The most natural size of integer for the machine.  \nfloat A single -precision floating point value.  \ndouble  A double -precision floating point value.  \nvoid Represent s the absence of type.  \nwchar_t  A wide character type.  \n \nC++ also allows to define various other types of variables, which we will cover in subsequent \nchapters like  Enumeration, Pointer, Array, Reference, Data structures,  and Classes . \nFollowing section wil l cover how to define, declare and use various types of variables.  6. VARIABLE TYPES  "}, {'page_number': 28, 'content': "  C++ \n28 \n \nVariable Definition in C++  \nA variable definition tells the compiler where and how much storage to create for the variable. \nA variable definition specifies a data type, and contains a list o f one or more variables of that \ntype as follows:  \ntype variable_list ; \nHere,  type  must be a valid C++ data type including char, w_char, int, float, double, bool or \nany user -defined object, etc., and  variable_list  may consist of one or more identifier names \nseparated by commas. Some valid declarations are shown here:  \nint    i, j, k; \nchar   c, ch; \nfloat  f, salary; \ndouble d; \nThe line  int i, j, k;  both declares and defines the variables i, j and k; which instructs the \ncompiler to create variables named i, j and k of type int.  \nVariables can be initialized (assigned an initial value) in their declaration. The initializer \nconsists of an equal sign followed by a constant expression as follows:  \ntype variable_name = value; \nSome examples are:  \nextern int d = 3, f = 5;    // declaration of d and f.  \nint d = 3, f = 5;           // definition and initializing d and f.  \nbyte z = 22;                // definition and initializes z.  \nchar x = 'x';               // the variable x has the value 'x'.  \nFor definition without an initi alizer: variables with static storage duration are implicitly \ninitialized with NULL (all bytes have the value 0); the initial value of all other variables is \nundefined.  \nVariable Declaration in C++  \nA variable declaration provides assurance to the compiler t hat there is one variable existing \nwith the given type and name so that compiler proceed for further compilation without \nneeding complete detail about the variable. A variable declaration has its meaning at the time \nof compilation only, compiler needs actu al variable declaration at the time of linking of the \nprogram.  "}, {'page_number': 29, 'content': '  C++ \n29 \n \nA variable declaration is useful when you are using multiple files and you define your variable \nin one of the files which will be available at the time of linking of the program. You will \nuse extern  keyword to declare a variable at any place. Though you can declare a variable \nmultiple times in your C++ program, but it can be defined only once in a file, a function or a \nblock of code.  \nExample  \nTry the following example where a variable has been de clared at the top, but it has been \ndefined inside the main function:  \n#include  <iostream>  \nusing namespace  std; \n \n// Variable declaration:  \nextern int a, b; \nextern int c; \nextern float f; \n   \nint main () \n{ \n  // Variable definition:  \n  int a, b; \n  int c; \n  float f; \n  \n  // actual initialization  \n  a = 10; \n  b = 20; \n  c = a + b; \n  \n  cout << c << endl ; \n \n  f = 70.0/3.0; \n  cout << f << endl ; \n  '}, {'page_number': 30, 'content': '  C++ \n30 \n \n  return 0; \n} \n \nWhen the above code is compiled and executed, it produces the following result:  \n30 \n23.3333 \nSame concept applies on function declaration where you provide a function name at the time \nof its declaration and its actual definition can be given anywhere else. For example:  \n// function declaration  \nint func(); \n \nint main() \n{ \n    // function call  \n    int i = func(); \n} \n \n// function definition  \nint func() \n{ \n    return 0; \n} \nLvalues and Rvalues  \nThere are two kinds of expressions in C++:  \n\uf0b7 lvalue :  Expressions that refer to a memory location is called "lvalue" expression. An \nlvalue may appear as either the left -hand or right -hand side  of an assignment.  \n\uf0b7 rvalue :  The term rvalue refers to a data value that is stored at some address in \nmemory. An rvalue is an expression that cannot have a value assigned to it which \nmeans an rvalue may appear on the right - but not left -hand side of an assi gnment.  '}, {'page_number': 31, 'content': '  C++ \n31 \n \nVariables are lvalues and so may appear on the left -hand side of an assignment. Numeric \nliterals are rvalues and so may not be assigned and cannot appear on the left -hand side. \nFollowing is a valid statement:  \nint g = 20; \nBut the following is not a valid statement and would generate compile -time error:  \n10 = 20; \n '}, {'page_number': 32, 'content': "  C++ \n32 \n \nA scope is a region of the program and broadly speaking there are three places, where \nvariables can be declared:  \n\uf0b7 Inside a function or a block which is called local variable s, \n\uf0b7 In the definition of function parameters which is called formal parameters.  \n\uf0b7 Outside of all functions which is called global variables.  \nWe will learn what a function is, and it's parameter in subsequent chapters. Here let us explain \nwhat local and global  variables are.  \nLocal Variables  \nVariables that are declared inside a function or block are local variables. They can be used \nonly by statements that are inside that function or block of code. Local variables are not \nknown to functions outside their own. Fo llowing is the example using local variables:  \n#include  <iostream>  \nusing namespace  std; \n  \nint main () \n{ \n  // Local variable declaration:  \n  int a, b; \n  int c; \n  \n  // actual initialization  \n  a = 10; \n  b = 20; \n  c = a + b; \n  \n  cout << c; \n  \n  return 0; 7. VARIABLE S COPE  "}, {'page_number': 33, 'content': '  C++ \n33 \n \n} \nGlobal  Variables  \nGlobal variables are defined outside of all the functions, usually on top of the program. The \nglobal variables will hold their value throughout the life -time of your program.  \nA global variable can be accessed by any function. That is, a global v ariable is available for \nuse throughout your entire program after its declaration. Following is the example using global \nand local variables:  \n#include  <iostream>  \nusing namespace  std; \n  \n// Global variable declaration:  \nint g; \n  \nint main () \n{ \n  // Local varia ble declaration:  \n  int a, b; \n  \n  // actual initialization  \n  a = 10; \n  b = 20; \n  g = a + b; \n  \n  cout << g; \n  \n  return 0; \n} \nA program can have same name for local and global variables but value of local variable inside \na function will take preference. For ex ample:  \n#include  <iostream>  \nusing namespace  std; '}, {'page_number': 34, 'content': "  C++ \n34 \n \n  \n// Global variable declaration:  \nint g = 20; \n  \nint main () \n{ \n  // Local variable declaration:  \n  int g = 10; \n  \n  cout << g; \n  \n  return 0; \n} \nWhen the above code is compiled and executed, it produces the follow ing result:  \n10 \nInitializing Local and Global Variables  \nWhen a local variable is defined, it is not initialized by the system, you must initialize it \nyourself. Global variables are initialized automatically by the system when you define them \nas follows:  \nData Type  Initializer  \nint 0 \nchar '\\0' \nfloat 0 \ndouble  0 \npointer  NULL \n "}, {'page_number': 35, 'content': '  C++ \n35 \n \nIt is a good programming practice to initialize variables properly, otherwise sometimes \nprogram would produce unexpected result.  \n '}, {'page_number': 36, 'content': '  C++ \n36 \n \nConstants refer to fixed values that the program may not alter and they are called  literals . \nConstants can be of any of the basic data types and can be divided into Integer Numerals, \nFloating -Point Numerals, Characters, Strings and Boolean Values.  \nAgain, constants are treated just like r egular variables except that their values cannot be \nmodified after their definition.  \nInteger Literals  \nAn integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base \nor radix: 0x or 0X for hexadecimal, 0 for octal, and noth ing for decimal.  \nAn integer literal can also have a suffix that is a combination of U and L, for unsigned and \nlong, respectively. The suffix can be uppercase or lowercase and can be in any order.  \nHere are some examples of integer literals:  \n212         // Legal \n215u        // Legal  \n0xFeeL      // Legal  \n078         // Illegal: 8 is not an octal digit  \n032UU       // Illegal: cannot repeat a suffix  \nFollowing are other examples of various types of Integer literals:  \n85         // decimal  \n0213       // octal  \n0x4b       // hexadecimal  \n30         // int \n30u        // unsigned int  \n30l        // long \n30ul       // unsigned long  8. CONSTANTS/LITERAL S '}, {'page_number': 37, 'content': "  C++ \n37 \n \nFloating -point Literals  \nA floating -point literal has an integer part, a decimal point, a fractional part, and an exponent \npart. You can represe nt floating point literals either in decimal form or exponential form.  \nWhile representing using decimal form, you must include the decimal point, the exponent, or \nboth and while representing using exponential form, you must include the integer part, the \nfractional part, or both. The signed exponent is introduced by e or E.  \nHere are some examples of floating -point literals:  \n3.14159       // Legal  \n314159E-5L    // Legal  \n510E          // Illegal: incomplete exponent  \n210f          // Illegal: no decimal or expo nent \n.e55          // Illegal: missing integer or fraction  \nBoolean Literals  \nThere are two Boolean literals and they are part of standard C++ keywords:  \n\uf0b7 A value of  true  representing true.  \n\uf0b7 A value of  false  representing false.  \nYou should not consider the value  of true equal to 1 and value of false equal to 0.  \nCharacter Literals  \nCharacter literals are enclosed in single quotes. If the literal begins with L (uppercase only), \nit is a wide character literal (e.g., L'x') and should be stored in  wchar_t  type of varia ble. \nOtherwise, it is a narrow character literal (e.g., 'x') and can be stored in a simple variable of \nchar  type. \nA character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., ' \\t'), or a \nuniversal character (e.g., ' \\u02C0').  \nThere ar e certain characters in C++ when they are preceded by a backslash they will have \nspecial meaning and they are used to represent like newline ( \\n) or tab ( \\t). Here, you have \na list of some of such escape sequence codes:  \nEscape sequence  Meaning  \n\\\\ \\ charac ter "}, {'page_number': 38, 'content': '  C++ \n38 \n \n\\\' \' character  \n\\" " character  \n\\? ? character  \n\\a Alert or bell  \n\\b Backspace  \n\\f Form feed  \n\\n Newline  \n\\r Carriage return  \n\\t Horizontal tab  \n\\v Vertical tab  \n\\ooo Octal number of one to three digits  \n\\xhh . . .  Hexadecimal number of one or more di gits \n \nFollowing is the example to show a few escape sequence characters:  \n#include  <iostream>  \nusing namespace  std; \n \nint main() \n{ \n   cout << "Hello\\tWorld\\n\\n"; \n   return 0; \n} '}, {'page_number': 39, 'content': '  C++ \n39 \n \n \nWhen the above code is compiled and executed, it produces the following result:  \nHello   World \nString Literals  \nString literals are enclosed in double quotes. A string contains characters that are similar to \ncharacter literals: plain characters, escape sequences, and universal characters.  \nYou can break a long line into multiple lines us ing string literals and separate them using \nwhitespaces.  \nHere are some examples of string literals. All the three forms are identical strings.  \n"hello, dear"  \n \n"hello, \\ \n \ndear" \n \n"hello, "  "d" "ear" \nDefining Constants  \nThere are two simple ways in C++ to defin e constants:  \n\uf0b7 Using  #define  preprocessor.  \n\uf0b7 Using  const  keyword.  \nThe #define Preprocessor  \nFollowing is the form to use #define preprocessor to define a constant:  \n#define identifier value  \nFollowing example explains it in detail:  \n#include  <iostream>  \nusing namespace std; \n '}, {'page_number': 40, 'content': "  C++ \n40 \n \n#define LENGTH 10    \n#define WIDTH  5 \n#define NEWLINE '\\n' \n \nint main() \n{ \n \n   int area;   \n    \n   area = LENGTH * WIDTH; \n   cout << area; \n   cout << NEWLINE; \n   return 0; \n} \nWhen the above code is compiled and executed, it produces the following re sult: \n50 \nThe const Keyword  \nYou can use  const  prefix to declare constants with a specific type as follows:  \nconst type variable = value; \nFollowing example explains it in detail:  \n#include  <iostream>  \nusing namespace  std; \n \nint main() \n{ \n   const int  LENGTH = 10; \n   const int  WIDTH  = 5; \n   const char NEWLINE = '\\n'; \n   int area;   "}, {'page_number': 41, 'content': '  C++ \n41 \n \n    \n   area = LENGTH * WIDTH; \n   cout << area; \n   cout << NEWLINE; \n   return 0; \n} \nWhen the above code is compiled and executed, it produces the following result:  \n50 \nNote that it is a good programming practice to define constants in CAPITALS.  \n '}, {'page_number': 42, 'content': '  C++ \n42 \n \nC++ allows the  char, int,  and double  data types to have modifiers preceding them. A \nmodifier is used to alter the meaning of the base type so that it more precisely fits the need s \nof various situations.  \nThe data type modifiers are listed here:  \n\uf0b7 signed  \n\uf0b7 unsigned  \n\uf0b7 long \n\uf0b7 short \nThe modifiers  signed, unsigned, long,  and short  can be applied to integer base types. In \naddition,  signed  and unsigned  can be applied to char, and  long  can be appl ied to double.  \nThe modifiers  signed  and unsigned  can also be used as prefix to  long  or short  modifiers. \nFor example,  unsigned long int . \nC++ allows a shorthand notation for declaring  unsigned, short,  or long  integers. You can \nsimply use the word  unsigned, s hort,  or long, without int. It automatically implies int. For \nexample, the following two statements both declare unsigned integer variables.  \nunsigned  x; \nunsigned  int y; \nTo understand the difference between the way signed and unsigned integer modifiers are \ninterpreted by C++, you should run the following short program:  \n#include  <iostream>  \nusing namespace  std; \n  \n/* This program shows the difference between  \n * signed and unsigned integers.  \n*/ \nint main() \n{ \n   short int i;           // a signed short integer  9. MODIFIER TYPES  '}, {'page_number': 43, 'content': '  C++ \n43 \n \n   short unsigned  int j;  // an unsigned short integer  \n \n   j = 50000; \n \n   i = j; \n   cout << i << " " << j; \n \n   return 0; \n} \nWhen this program is run, following is the output:  \n-15536 50000 \nThe above result is because the bit pattern that represents 50,000 as a short unsigned integer \nis interpreted as -15,536 by a short.  \nT ype Qualifiers in C++  \nThe type qualifiers provide additional information about the variables they precede.  \nQualifier  Meaning  \nconst  Objects of type  const  cannot be changed by your program during  execution  \nvolatile  The modifier  volatile  tells the compiler that a variable\'s value may be \nchanged in ways not explicitly specified by the program.  \nrestrict  A pointer qualified by  restrict  is initially the only means by which the object \nit points to can  be accessed. Only C99 adds a new type qualifier called \nrestrict.  \n \n \n \n '}, {'page_number': 44, 'content': "  C++ \n44 \n \nA storage class defines the scope (visibility) and life -time of variables and/or functions within \na C++ Program. These specifiers precede the type that they modify. There are following \nstorage classes, which can be used in a C++ Program  \n\uf0b7 auto \n\uf0b7 register  \n\uf0b7 static  \n\uf0b7 extern  \n\uf0b7 mutable  \nThe auto Storage Class  \nThe auto  storage class is the default storage class for all local variables.  \n{ \n   int mount; \n   auto int month; \n} \nThe example  above defines two variables with the same storage class, auto can only be used \nwithin functions, i.e., local variables.  \nThe register Storage Class  \nThe register  storage class is used to define local variables that should be stored in a register \ninstead of RAM. This means that the variable has a maximum size equal to the register size \n(usually one word) and can't have the unary '&' operator applied to it (as it does not have a \nmemory location).  \n{ \n   register  int  miles; \n} \nThe register should only be used for  variables that require quick access such as counters. It \nshould also be noted that defining 'register' does not mean that the variable will be stored in 10. STORAGE CLASSES  "}, {'page_number': 45, 'content': '  C++ \n45 \n \na register. It means that it MIGHT be stored in a register depending on hardware and \nimplementation re strictions.  \nThe static Storage Class  \nThe static  storage class instructs the compiler to keep a local variable in existence during the \nlife-time of the program instead of creating and destroying it each time it comes into and \ngoes out of scope. Therefore, m aking local variables static allows them to maintain their \nvalues between function calls.  \nThe static modifier may also be applied to global variables. When this is done, it causes that \nvariable\'s scope to be restricted to the file in which it is declared.  \nIn C++, when static is used on a class data member, it causes only one copy of that member \nto be shared by all objects of its class.  \n#include  <iostream>  \n  \n// Function declaration  \nvoid func(void); \n  \nstatic int count = 10; /* Global variable */  \n  \nmain() \n{ \n    while(count--) \n    { \n       func(); \n    } \n    return 0; \n} \n// Function definition  \nvoid func( void ) \n{ \n    static int i = 5; // local static variable  \n    i++; \n    std::cout << "i is " << i ; \n    std::cout << " and count is "  << count << std::endl; '}, {'page_number': 46, 'content': "  C++ \n46 \n \n} \nWhen t he above code is compiled and executed, it produces the following result:  \ni is 6 and count is 9 \ni is 7 and count is 8 \ni is 8 and count is 7 \ni is 9 and count is 6 \ni is 10 and count is 5 \ni is 11 and count is 4 \ni is 12 and count is 3 \ni is 13 and count is 2 \ni is 14 and count is 1 \ni is 15 and count is 0 \nThe extern Storage Class  \nThe extern  storage class is used to give a reference of a global variable that is visible to ALL \nthe program files. When you use 'extern' the variable cannot be initialized as all it does  is \npoint the variable name at a storage location that has been previously defined.  \nWhen you have multiple files and you define a global variable or function, which will be used \nin other files also, then  extern  will be used in another file to give referenc e of defined variable \nor function. Just for understanding  extern  is used to declare a global variable or function in \nanother file.  \nThe extern modifier is most commonly used when there are two or more files sharing the \nsame global variables or functions as explained below.  \nFirst File: main.cpp  \n#include  <iostream>  \n  \nint count ; \nextern void write_extern (); \n  \nmain() \n{ \n   count = 5; "}, {'page_number': 47, 'content': '  C++ \n47 \n \n   write_extern (); \n} \nSecond File: support.cpp  \n#include  <iostream>  \n  \nextern int count; \n  \nvoid write_extern (void) \n{ \n   std::cout << "Count is "  << count << std::endl; \n} \nHere,  extern  keyword is being used to declare count in another file. Now compile these two \nfiles as follows:  \n$g++ main.cpp support .cpp -o write \nThis will produce  write  executable program, try to execute  write  and check t he result as \nfollows:  \n$./write \n5 \nThe mutable Storage Class  \nThe mutable  specifier applies only to class objects, which are discussed later in this tutorial. \nIt allows a member of an object to override const member function. That is, a mutable \nmember can be modified by a const member function.  \n '}, {'page_number': 48, 'content': '  C++ \n48 \n \nAn operator is a symbol that tells the compiler to perform specific mathematical or logical \nmanipulations. C++ is rich in built -in operators and provide the following types of operators:  \n\uf0b7 Arithmetic Operat ors \n\uf0b7 Relational Operators  \n\uf0b7 Logical Operators  \n\uf0b7 Bitwise Operators  \n\uf0b7 Assignment Operators  \n\uf0b7 Misc Operators  \nThis chapter will examine the arithmetic, relational, logical, bitwise, assignment and other \noperators one by one.  \nArithmetic Operators  \nThere are following ari thmetic operators supported by C++ language:  \nAssume variable A holds 10 and variable B holds 20, then:  \n \nOperator  Description  Example  \n+ Adds two operands  A + B will give 30  \n- Subtracts second operand from the \nfirst A - B will give -10 \n* Multiplies both o perands  A * B will give 200  \n/ Divides numerator by de -numerator  B / A will give 2  \n% Modulus Operator and remainder of \nafter an integer division  B % A will give 0  11. OPERATORS  '}, {'page_number': 49, 'content': '  C++ \n49 \n \n++ Increment operator , increases \ninteger value by one  A++ will give 11  \n-- Decrement operat or, decreases \ninteger value by one  A-- will give 9  \n \nTry the following example to understand all the arithmetic operators available in C++.  \nCopy and paste the following C++ program in test.cpp file and compile and run this program.  \n#include <iostream>  \nusing namespace std;  \n  \nmain() \n{ \n   int a = 21;  \n   int b = 10;  \n   int c ; \n  \n   c = a + b;  \n   cout << "Line 1 - Value of c is :" << c << endl ;  \n   c = a - b; \n   cout << "Line 2 - Value of c is  :" << c << endl ;  \n   c = a * b;  \n   cout << "Line 3 - Value of c is : " << c << endl ;  \n   c = a / b;  \n   cout << "Line 4 - Value of c is  :" << c << endl ;  \n   c = a % b;  \n   cout << "Line 5 - Value of c is  :" << c << endl ;  \n   c = a++;  \n   cout << "Line 6 - Value of c is :" << c << endl ;  \n   c = a--;  \n   cout << "Line 7 - Value of c is  :" << c << endl ;  \n   return 0;  '}, {'page_number': 50, 'content': '  C++ \n50 \n \n} \nWhen the above code is compiled and executed, it produces the following result:  \nLine 1 - Value of c is :31  \nLine 2 - Value of c is  :11  \nLine 3 - Value of c is :210  \nLine 4 - Value of c is  :2  \nLine 5 - Value of c i s  :1 \nLine 6 - Value of c is :21  \nLine 7 - Value of c is  :22  \n \nRelational Operators  \nThere are following relational operators supported by C++ language  \nAssume variable A holds 10 and variable B holds 20, then:  \nOperator  Description  Example  \n== Checks if the v alues of two operands \nare equal or not, if yes then \ncondition becomes true.  (A == B) is not true.  \n!= Checks if the values of two operands \nare equal or not, if values are not \nequal then condition becomes true.  (A != B) is true.  \n> Checks if the value of le ft operand is \ngreater than the value of right \noperand, if yes then condition \nbecomes true.  (A > B) is not true.  \n< Checks if the value of left operand is \nless than the value of right operand, \nif yes then condition becomes true.  (A < B) is true.  '}, {'page_number': 51, 'content': '  C++ \n51 \n \n>= Checks if the value of left operand is \ngreater than or equal to the value of \nright operand, if yes then condition \nbecomes true.  (A >= B) is not true.  \n<= Checks if the value of left operand is \nless than or equal to the value of \nright operand, if yes then conditio n \nbecomes true.  (A <= B) is true.  \n \nTry the following example to understand all the relational operators available in C++.  \nCopy and paste the following C++ program in test.cpp file and compile and run this program.  \n#include <iostream>  \nusing namespace std;  \n \nmain() \n{ \n   int a = 21;  \n   int b = 10;  \n   int c ; \n \n   if( a == b )  \n   { \n      cout << "Line 1 - a is equal to b" << endl ;  \n   } \n   else \n   { \n      cout << "Line 1 - a is not equal to b" << endl ;  \n   } \n   if ( a < b )  \n   { \n      cout << "Line 2 - a is less  than b" << endl ;  \n   } '}, {'page_number': 52, 'content': '  C++ \n52 \n \n   else \n   { \n      cout << "Line 2 - a is not less than b" << endl ;  \n   } \n   if ( a > b )  \n   { \n      cout << "Line 3 - a is greater than b" << endl ;  \n   } \n   else \n   { \n      cout << "Line 3 - a is not greater than b" << endl ;  \n   } \n   /* Let\'s change the values of a and b */  \n   a = 5; \n   b = 20; \n  '}, {'page_number': 53, 'content': '  C++ \n53 \n \nEnd of ebook preview  \nIf you liked what you saw … \nBuy it from our store @ https://store.tutorialspoint.com  '}])